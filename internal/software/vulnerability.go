// Package software provides software inventory and SBOM functionality.
package software

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/levantar-ai/mcp-sysinfo/pkg/types"
)

// GetVulnerabilitiesOSV queries the OSV API for vulnerabilities in installed packages.
func (c *Collector) GetVulnerabilitiesOSV() (*types.VulnerabilityResult, error) {
	result := &types.VulnerabilityResult{
		Vulnerabilities: []types.Vulnerability{},
		Source:          "osv",
		Timestamp:       time.Now(),
	}

	// Collect packages to check
	packages := c.collectPackagesForVulnCheck()
	if len(packages) == 0 {
		return result, nil
	}

	client := &http.Client{Timeout: 30 * time.Second}

	// Query OSV API for each package ecosystem
	for ecosystem, pkgs := range packages {
		for _, pkg := range pkgs {
			vulns, err := queryOSV(client, ecosystem, pkg.Name, pkg.Version)
			if err != nil {
				continue // Skip on error, don't fail entire query
			}

			for _, v := range vulns {
				vuln := types.Vulnerability{
					ID:       v.ID,
					Summary:  v.Summary,
					Details:  v.Details,
					Package:  pkg.Name,
					Version:  pkg.Version,
					Severity: mapOSVSeverity(v.Severity),
				}

				if len(v.Aliases) > 0 {
					vuln.Aliases = v.Aliases
				}

				if len(v.Affected) > 0 && len(v.Affected[0].Ranges) > 0 {
					for _, r := range v.Affected[0].Ranges {
						for _, event := range r.Events {
							if event.Fixed != "" {
								vuln.FixedIn = event.Fixed
								break
							}
						}
					}
				}

				if len(v.References) > 0 {
					for _, ref := range v.References {
						vuln.References = append(vuln.References, ref.URL)
					}
				}

				vuln.Published = v.Published
				vuln.Modified = v.Modified

				result.Vulnerabilities = append(result.Vulnerabilities, vuln)

				// Count by severity
				switch vuln.Severity {
				case "CRITICAL":
					result.Critical++
				case "HIGH":
					result.High++
				case "MEDIUM":
					result.Medium++
				case "LOW":
					result.Low++
				}
			}
		}
	}

	result.Count = len(result.Vulnerabilities)
	return result, nil
}

type pkgInfo struct {
	Name    string
	Version string
}

func (c *Collector) collectPackagesForVulnCheck() map[string][]pkgInfo {
	packages := make(map[string][]pkgInfo)

	// Python packages
	pyPkgs, _ := c.GetPythonPackages()
	if pyPkgs != nil {
		for _, pkg := range pyPkgs.Packages {
			packages["PyPI"] = append(packages["PyPI"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Node packages
	nodePkgs, _ := c.GetNodePackages()
	if nodePkgs != nil {
		for _, pkg := range nodePkgs.Packages {
			packages["npm"] = append(packages["npm"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Go modules
	goPkgs, _ := c.GetGoModules()
	if goPkgs != nil {
		for _, pkg := range goPkgs.Packages {
			packages["Go"] = append(packages["Go"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Rust crates
	rustPkgs, _ := c.GetRustPackages()
	if rustPkgs != nil {
		for _, pkg := range rustPkgs.Packages {
			packages["crates.io"] = append(packages["crates.io"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Ruby gems
	rubyPkgs, _ := c.GetRubyGems()
	if rubyPkgs != nil {
		for _, pkg := range rubyPkgs.Packages {
			packages["RubyGems"] = append(packages["RubyGems"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	return packages
}

func queryOSV(client *http.Client, ecosystem, name, version string) ([]osvVulnerability, error) {
	query := osvQuery{
		Package: osvPackage{
			Name:      name,
			Ecosystem: ecosystem,
		},
		Version: version,
	}

	body, err := json.Marshal(query)
	if err != nil {
		return nil, err
	}

	resp, err := client.Post("https://api.osv.dev/v1/query", "application/json", bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("OSV API returned %d", resp.StatusCode)
	}

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result osvResponse
	if err := json.Unmarshal(respBody, &result); err != nil {
		return nil, err
	}

	return result.Vulns, nil
}

func mapOSVSeverity(severity []osvSeverity) string {
	if len(severity) == 0 {
		return "UNKNOWN"
	}

	// Find CVSS v3 score if available
	for _, s := range severity {
		if strings.HasPrefix(s.Type, "CVSS_V3") {
			score := parseCVSSScore(s.Score)
			if score >= 9.0 {
				return "CRITICAL"
			} else if score >= 7.0 {
				return "HIGH"
			} else if score >= 4.0 {
				return "MEDIUM"
			} else if score > 0 {
				return "LOW"
			}
		}
	}

	return "UNKNOWN"
}

func parseCVSSScore(score string) float64 {
	// CVSS vector string format: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
	// We'd need to calculate the score, but for simplicity, return 0
	// In production, use a proper CVSS library
	return 0
}

// OSV API types
type osvQuery struct {
	Package osvPackage `json:"package"`
	Version string     `json:"version"`
}

type osvPackage struct {
	Name      string `json:"name"`
	Ecosystem string `json:"ecosystem"`
}

type osvResponse struct {
	Vulns []osvVulnerability `json:"vulns"`
}

type osvVulnerability struct {
	ID         string        `json:"id"`
	Summary    string        `json:"summary"`
	Details    string        `json:"details"`
	Aliases    []string      `json:"aliases"`
	Severity   []osvSeverity `json:"severity"`
	Affected   []osvAffected `json:"affected"`
	References []osvRef      `json:"references"`
	Published  string        `json:"published"`
	Modified   string        `json:"modified"`
}

type osvSeverity struct {
	Type  string `json:"type"`
	Score string `json:"score"`
}

type osvAffected struct {
	Package osvPackage `json:"package"`
	Ranges  []osvRange `json:"ranges"`
}

type osvRange struct {
	Type   string     `json:"type"`
	Events []osvEvent `json:"events"`
}

type osvEvent struct {
	Introduced string `json:"introduced"`
	Fixed      string `json:"fixed"`
}

type osvRef struct {
	Type string `json:"type"`
	URL  string `json:"url"`
}

// GetVulnerabilitiesDebian checks Debian security tracker for vulnerabilities.
func (c *Collector) GetVulnerabilitiesDebian() (*types.VulnerabilityResult, error) {
	result := &types.VulnerabilityResult{
		Vulnerabilities: []types.Vulnerability{},
		Source:          "debian",
		Timestamp:       time.Now(),
	}

	// Get system packages first
	sysPkgs, err := c.GetSystemPackages()
	if err != nil || sysPkgs == nil || sysPkgs.PackageManager != "dpkg" {
		// Not a Debian-based system
		return result, nil
	}

	// Query Debian Security Tracker JSON API
	client := &http.Client{Timeout: 60 * time.Second}
	resp, err := client.Get("https://security-tracker.debian.org/tracker/data/json")
	if err != nil {
		result.Error = fmt.Sprintf("Failed to fetch Debian security tracker: %v", err)
		return result, nil
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		result.Error = fmt.Sprintf("Debian security tracker returned %d", resp.StatusCode)
		return result, nil
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		result.Error = fmt.Sprintf("Failed to read response: %v", err)
		return result, nil
	}

	var tracker map[string]map[string]debianCVE
	if err := json.Unmarshal(body, &tracker); err != nil {
		result.Error = fmt.Sprintf("Failed to parse security data: %v", err)
		return result, nil
	}

	// Create map of installed packages for quick lookup
	installed := make(map[string]string)
	for _, pkg := range sysPkgs.Packages {
		installed[pkg.Name] = pkg.Version
	}

	// Check each package against the security tracker
	for pkgName, cves := range tracker {
		installedVersion, ok := installed[pkgName]
		if !ok {
			continue
		}

		for cveID, cve := range cves {
			if cve.Releases == nil {
				continue
			}

			// Check each release (we'll use the most relevant one)
			for _, release := range cve.Releases {
				if release.Status == "resolved" {
					continue // Already fixed
				}

				vuln := types.Vulnerability{
					ID:       cveID,
					Summary:  cve.Description,
					Package:  pkgName,
					Version:  installedVersion,
					Severity: mapDebianUrgency(release.Urgency),
				}

				if release.FixedVersion != "" && release.FixedVersion != "0" {
					vuln.FixedIn = release.FixedVersion
				}

				result.Vulnerabilities = append(result.Vulnerabilities, vuln)

				// Count by severity
				switch vuln.Severity {
				case "CRITICAL":
					result.Critical++
				case "HIGH":
					result.High++
				case "MEDIUM":
					result.Medium++
				case "LOW":
					result.Low++
				}
				break // Only add once per CVE
			}
		}
	}

	result.Count = len(result.Vulnerabilities)
	return result, nil
}

type debianCVE struct {
	Description string                      `json:"description"`
	Releases    map[string]debianCVERelease `json:"releases"`
}

type debianCVERelease struct {
	Status       string `json:"status"`
	Urgency      string `json:"urgency"`
	FixedVersion string `json:"fixed_version"`
}

func mapDebianUrgency(urgency string) string {
	switch strings.ToLower(urgency) {
	case "high", "not yet assigned":
		return "HIGH"
	case "medium":
		return "MEDIUM"
	case "low":
		return "LOW"
	case "unimportant":
		return "LOW"
	default:
		return "UNKNOWN"
	}
}

// GetVulnerabilitiesNVD queries the NVD API for vulnerabilities.
func (c *Collector) GetVulnerabilitiesNVD() (*types.VulnerabilityResult, error) {
	result := &types.VulnerabilityResult{
		Vulnerabilities: []types.Vulnerability{},
		Source:          "nvd",
		Timestamp:       time.Now(),
	}

	// Collect packages to check
	packages := c.collectPackagesForVulnCheck()
	if len(packages) == 0 {
		return result, nil
	}

	client := &http.Client{Timeout: 60 * time.Second}

	// Add system packages too
	sysPkgs, _ := c.GetSystemPackages()
	if sysPkgs != nil && len(sysPkgs.Packages) > 0 {
		for _, pkg := range sysPkgs.Packages {
			if pkg.Name != "" && pkg.Version != "" {
				packages["system"] = append(packages["system"], pkgInfo{pkg.Name, pkg.Version})
			}
		}
	}

	// Query NVD API for CPE matches
	// Note: NVD API 2.0 requires API key for higher rate limits
	// Without key: 5 requests per 30 seconds
	requestCount := 0
	maxRequests := 10 // Limit queries to avoid rate limiting

	for _, pkgs := range packages {
		for _, pkg := range pkgs {
			if requestCount >= maxRequests {
				break
			}

			vulns, err := queryNVD(client, pkg.Name, pkg.Version)
			if err != nil {
				continue
			}
			requestCount++

			for _, v := range vulns {
				result.Vulnerabilities = append(result.Vulnerabilities, v)

				switch v.Severity {
				case "CRITICAL":
					result.Critical++
				case "HIGH":
					result.High++
				case "MEDIUM":
					result.Medium++
				case "LOW":
					result.Low++
				}
			}

			// Rate limiting: sleep between requests
			time.Sleep(200 * time.Millisecond)
		}
		if requestCount >= maxRequests {
			break
		}
	}

	result.Count = len(result.Vulnerabilities)
	return result, nil
}

func queryNVD(client *http.Client, pkgName, version string) ([]types.Vulnerability, error) {
	var vulns []types.Vulnerability

	// Build CPE search URL
	// Format: cpe:2.3:a:*:package_name:version:*:*:*:*:*:*:*
	url := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=%s", pkgName)

	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("NVD API returned %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var nvdResp nvdResponse
	if err := json.Unmarshal(body, &nvdResp); err != nil {
		return nil, err
	}

	for _, cve := range nvdResp.Vulnerabilities {
		vuln := types.Vulnerability{
			ID:        cve.CVE.ID,
			Summary:   extractNVDDescription(cve.CVE.Descriptions),
			Package:   pkgName,
			Version:   version,
			Published: cve.CVE.Published,
			Modified:  cve.CVE.LastModified,
		}

		// Extract severity from CVSS
		if len(cve.CVE.Metrics.CVSSV31) > 0 {
			cvss := cve.CVE.Metrics.CVSSV31[0]
			vuln.CVSS = cvss.CVSSData.BaseScore
			vuln.Severity = mapCVSSSeverity(cvss.CVSSData.BaseScore)
		} else if len(cve.CVE.Metrics.CVSSV30) > 0 {
			cvss := cve.CVE.Metrics.CVSSV30[0]
			vuln.CVSS = cvss.CVSSData.BaseScore
			vuln.Severity = mapCVSSSeverity(cvss.CVSSData.BaseScore)
		} else if len(cve.CVE.Metrics.CVSSV2) > 0 {
			cvss := cve.CVE.Metrics.CVSSV2[0]
			vuln.CVSS = cvss.CVSSData.BaseScore
			vuln.Severity = mapCVSSSeverity(cvss.CVSSData.BaseScore)
		}

		// Extract references
		for _, ref := range cve.CVE.References {
			vuln.References = append(vuln.References, ref.URL)
		}

		vulns = append(vulns, vuln)
	}

	return vulns, nil
}

func extractNVDDescription(descriptions []nvdDescription) string {
	for _, d := range descriptions {
		if d.Lang == "en" {
			return d.Value
		}
	}
	if len(descriptions) > 0 {
		return descriptions[0].Value
	}
	return ""
}

func mapCVSSSeverity(score float64) string {
	if score >= 9.0 {
		return "CRITICAL"
	} else if score >= 7.0 {
		return "HIGH"
	} else if score >= 4.0 {
		return "MEDIUM"
	} else if score > 0 {
		return "LOW"
	}
	return "UNKNOWN"
}

// NVD API types
type nvdResponse struct {
	ResultsPerPage  int       `json:"resultsPerPage"`
	Vulnerabilities []nvdVuln `json:"vulnerabilities"`
}

type nvdVuln struct {
	CVE nvdCVE `json:"cve"`
}

type nvdCVE struct {
	ID           string           `json:"id"`
	Descriptions []nvdDescription `json:"descriptions"`
	Published    string           `json:"published"`
	LastModified string           `json:"lastModified"`
	Metrics      nvdMetrics       `json:"metrics"`
	References   []nvdReference   `json:"references"`
}

type nvdDescription struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type nvdMetrics struct {
	CVSSV31 []nvdCVSS `json:"cvssMetricV31"`
	CVSSV30 []nvdCVSS `json:"cvssMetricV30"`
	CVSSV2  []nvdCVSS `json:"cvssMetricV2"`
}

type nvdCVSS struct {
	CVSSData nvdCVSSData `json:"cvssData"`
}

type nvdCVSSData struct {
	BaseScore float64 `json:"baseScore"`
}

type nvdReference struct {
	URL string `json:"url"`
}
