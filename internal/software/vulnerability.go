// Package software provides software inventory and SBOM functionality.
package software

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/levantar-ai/mcp-sysinfo/pkg/types"
)

// GetVulnerabilitiesOSV queries the OSV API for vulnerabilities in installed packages.
func (c *Collector) GetVulnerabilitiesOSV() (*types.VulnerabilityResult, error) {
	result := &types.VulnerabilityResult{
		Vulnerabilities: []types.Vulnerability{},
		Source:          "osv",
		Timestamp:       time.Now(),
	}

	// Collect packages to check
	packages := c.collectPackagesForVulnCheck()
	if len(packages) == 0 {
		return result, nil
	}

	client := &http.Client{Timeout: 30 * time.Second}

	// Query OSV API for each package ecosystem
	for ecosystem, pkgs := range packages {
		for _, pkg := range pkgs {
			vulns, err := queryOSV(client, ecosystem, pkg.Name, pkg.Version)
			if err != nil {
				continue // Skip on error, don't fail entire query
			}

			for _, v := range vulns {
				vuln := types.Vulnerability{
					ID:       v.ID,
					Summary:  v.Summary,
					Details:  v.Details,
					Package:  pkg.Name,
					Version:  pkg.Version,
					Severity: mapOSVSeverity(v.Severity),
				}

				if len(v.Aliases) > 0 {
					vuln.Aliases = v.Aliases
				}

				if len(v.Affected) > 0 && len(v.Affected[0].Ranges) > 0 {
					for _, r := range v.Affected[0].Ranges {
						for _, event := range r.Events {
							if event.Fixed != "" {
								vuln.FixedIn = event.Fixed
								break
							}
						}
					}
				}

				if len(v.References) > 0 {
					for _, ref := range v.References {
						vuln.References = append(vuln.References, ref.URL)
					}
				}

				vuln.Published = v.Published
				vuln.Modified = v.Modified

				result.Vulnerabilities = append(result.Vulnerabilities, vuln)

				// Count by severity
				switch vuln.Severity {
				case "CRITICAL":
					result.Critical++
				case "HIGH":
					result.High++
				case "MEDIUM":
					result.Medium++
				case "LOW":
					result.Low++
				}
			}
		}
	}

	result.Count = len(result.Vulnerabilities)
	return result, nil
}

type pkgInfo struct {
	Name    string
	Version string
}

func (c *Collector) collectPackagesForVulnCheck() map[string][]pkgInfo {
	packages := make(map[string][]pkgInfo)

	// Python packages
	pyPkgs, _ := c.GetPythonPackages()
	if pyPkgs != nil {
		for _, pkg := range pyPkgs.Packages {
			packages["PyPI"] = append(packages["PyPI"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Node packages
	nodePkgs, _ := c.GetNodePackages()
	if nodePkgs != nil {
		for _, pkg := range nodePkgs.Packages {
			packages["npm"] = append(packages["npm"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Go modules
	goPkgs, _ := c.GetGoModules()
	if goPkgs != nil {
		for _, pkg := range goPkgs.Packages {
			packages["Go"] = append(packages["Go"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Rust crates
	rustPkgs, _ := c.GetRustPackages()
	if rustPkgs != nil {
		for _, pkg := range rustPkgs.Packages {
			packages["crates.io"] = append(packages["crates.io"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	// Ruby gems
	rubyPkgs, _ := c.GetRubyGems()
	if rubyPkgs != nil {
		for _, pkg := range rubyPkgs.Packages {
			packages["RubyGems"] = append(packages["RubyGems"], pkgInfo{pkg.Name, pkg.Version})
		}
	}

	return packages
}

func queryOSV(client *http.Client, ecosystem, name, version string) ([]osvVulnerability, error) {
	query := osvQuery{
		Package: osvPackage{
			Name:      name,
			Ecosystem: ecosystem,
		},
		Version: version,
	}

	body, err := json.Marshal(query)
	if err != nil {
		return nil, err
	}

	resp, err := client.Post("https://api.osv.dev/v1/query", "application/json", bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("OSV API returned %d", resp.StatusCode)
	}

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result osvResponse
	if err := json.Unmarshal(respBody, &result); err != nil {
		return nil, err
	}

	return result.Vulns, nil
}

func mapOSVSeverity(severity []osvSeverity) string {
	if len(severity) == 0 {
		return "UNKNOWN"
	}

	// Find CVSS v3 score if available
	for _, s := range severity {
		if strings.HasPrefix(s.Type, "CVSS_V3") {
			score := parseCVSSScore(s.Score)
			if score >= 9.0 {
				return "CRITICAL"
			} else if score >= 7.0 {
				return "HIGH"
			} else if score >= 4.0 {
				return "MEDIUM"
			} else if score > 0 {
				return "LOW"
			}
		}
	}

	return "UNKNOWN"
}

func parseCVSSScore(score string) float64 {
	// CVSS vector string format: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
	// We'd need to calculate the score, but for simplicity, return 0
	// In production, use a proper CVSS library
	return 0
}

// OSV API types
type osvQuery struct {
	Package osvPackage `json:"package"`
	Version string     `json:"version"`
}

type osvPackage struct {
	Name      string `json:"name"`
	Ecosystem string `json:"ecosystem"`
}

type osvResponse struct {
	Vulns []osvVulnerability `json:"vulns"`
}

type osvVulnerability struct {
	ID         string        `json:"id"`
	Summary    string        `json:"summary"`
	Details    string        `json:"details"`
	Aliases    []string      `json:"aliases"`
	Severity   []osvSeverity `json:"severity"`
	Affected   []osvAffected `json:"affected"`
	References []osvRef      `json:"references"`
	Published  string        `json:"published"`
	Modified   string        `json:"modified"`
}

type osvSeverity struct {
	Type  string `json:"type"`
	Score string `json:"score"`
}

type osvAffected struct {
	Package osvPackage  `json:"package"`
	Ranges  []osvRange  `json:"ranges"`
}

type osvRange struct {
	Type   string     `json:"type"`
	Events []osvEvent `json:"events"`
}

type osvEvent struct {
	Introduced string `json:"introduced"`
	Fixed      string `json:"fixed"`
}

type osvRef struct {
	Type string `json:"type"`
	URL  string `json:"url"`
}
