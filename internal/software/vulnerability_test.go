package software

import (
	"testing"
)

func TestGetVulnerabilitiesOSV(t *testing.T) {
	c := NewCollector()
	result, err := c.GetVulnerabilitiesOSV()

	if err != nil {
		t.Fatalf("GetVulnerabilitiesOSV returned error: %v", err)
	}

	if result == nil {
		t.Fatal("GetVulnerabilitiesOSV returned nil result")
	}

	if result.Source != "osv" {
		t.Errorf("expected source 'osv', got '%s'", result.Source)
	}

	if result.Timestamp.IsZero() {
		t.Error("Timestamp should not be zero")
	}

	if result.Count != len(result.Vulnerabilities) {
		t.Errorf("count mismatch: got %d, expected %d", result.Count, len(result.Vulnerabilities))
	}

	// Verify severity counts add up
	severityTotal := result.Critical + result.High + result.Medium + result.Low
	if result.Count > 0 && severityTotal == 0 {
		// If there are vulnerabilities, at least some should have severity
		// (though UNKNOWN severity is possible)
		t.Log("All vulnerabilities have UNKNOWN severity")
	}
}

func TestMapOSVSeverity(t *testing.T) {
	tests := []struct {
		name     string
		severity []osvSeverity
		expected string
	}{
		{
			name:     "empty severity",
			severity: []osvSeverity{},
			expected: "UNKNOWN",
		},
		{
			name: "CVSS v3 critical",
			severity: []osvSeverity{
				{Type: "CVSS_V3", Score: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H"},
			},
			// Note: parseCVSSScore returns 0, so this will be UNKNOWN
			expected: "UNKNOWN",
		},
		{
			name: "non-CVSS v3 type",
			severity: []osvSeverity{
				{Type: "CVSS_V2", Score: "AV:N/AC:L/Au:N/C:C/I:C/A:C"},
			},
			expected: "UNKNOWN",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := mapOSVSeverity(tc.severity)
			if result != tc.expected {
				t.Errorf("mapOSVSeverity() = %q, expected %q", result, tc.expected)
			}
		})
	}
}

func TestCollectPackagesForVulnCheck(t *testing.T) {
	c := NewCollector()
	packages := c.collectPackagesForVulnCheck()

	// This should return a map with ecosystem keys
	if packages == nil {
		t.Fatal("collectPackagesForVulnCheck returned nil")
	}

	// On most dev systems, at least one ecosystem should have packages
	// but we can't guarantee this on all CI systems
	t.Logf("Found packages in %d ecosystems", len(packages))

	for ecosystem, pkgs := range packages {
		if ecosystem == "" {
			t.Error("Found empty ecosystem key")
		}
		for _, pkg := range pkgs {
			if pkg.Name == "" {
				t.Errorf("Package in %s has empty name", ecosystem)
			}
		}
	}
}

func TestParseCVSSScore(t *testing.T) {
	// The current implementation returns 0 for all inputs
	// This is documented as a stub for simplicity
	tests := []struct {
		score    string
		expected float64
	}{
		{"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", 0},
		{"", 0},
		{"invalid", 0},
	}

	for _, tc := range tests {
		result := parseCVSSScore(tc.score)
		if result != tc.expected {
			t.Errorf("parseCVSSScore(%q) = %f, expected %f", tc.score, result, tc.expected)
		}
	}
}

// Benchmark tests
func BenchmarkCollectPackagesForVulnCheck(b *testing.B) {
	c := NewCollector()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = c.collectPackagesForVulnCheck()
	}
}
